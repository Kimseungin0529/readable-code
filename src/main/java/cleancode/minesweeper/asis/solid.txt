SRP : Single Responsibility Principle (단일 책임 원칙)

하나의 객체에는 하나의 책임만 있어야 한다.
하나의 객체 안에 책임이 많을수록 유지보수하기 힘들어진다.

우리가 평상시 사용하는 3 layer 구조에 대한 예시를 보자.
Controller -> Service -> Repository 에서 이 3가지 계층의 책임을 A라는 클래스에 다 넣어버린다면 어떻게 될까?

각 계층에 대한 책임이 무분별하게 섞이게 된다. 만약 Service 에 대한 기능을 추가, 변경, 삭제를 한다면
코드의 양은 배로 늘어 가독성이 좋아지지 않을 뿐더러 수정이 발생하는 경우에 중복된 곳을 모두 바꿔줘야 한다.
만약 중복된 부분이 10000개라면 언제 바꿀 것인가..?


OCP : Open-Close Principle (개방-폐쇠 원칙)
확장에는 열려 있으나 변경에는 닫혀 있어야 한다.
기능 확장을 하더라도 기존 코드에 영향을 미치면 안 된다는 의미이다.

우리는 할인 정책이라는 구체 클래스를 통해 기능을 구현했다. 기존 할인 정책은 총 결제 금액에 대해 10% 할인이다.
이러한 정책을 유지하다가 구매한 상품 개수마다 1000원 씩 할인하는 정책으로 변경하기로 했다.
우리는 할인 정책을 구현한 구체 클래스에 의존하기 때문에 할인 정책을 바꾸려면 기존 구체 클래스를 변경해야 한다.

이처럼 기능에 대한 변경이 일어날 때 마다 반복해서 수정해야 하는가...?
해결 방법으로 우리는 할인 정책을 인터페이스를 통한 추상화, 스펙화하고 이를 클래스로 구체화하면 된다.
기능 변경이 필요한 시점에 인터페이스에 대한 구체 클래스를 변경해주면 된다. 할인 정책이 담긴 인터페이스를 사용하는 입장에서는 해당 인터페이스만 알면 된다.
어떤 구체 클래스가 들어왔는 지 몰라도 된다. 따라서 새로운 기능이 구현하기 위해 코드를 작성하더라도(확장) 기존 코드의 대한 변경은 없다(폐쇠)

LSP : Liskov Substitution Principle (리스코프 치환 원칙)
객체는 스펙을 깨뜨리지 않으면서 자식 타입의 인스턴스로 바꿀 수 있어야 한다.
즉, 부모를 상속한 자식 클래스는 부모에게 상속받은 값, 기능은 의도대로 동작해야 한다는 것이다.
예시로 자동차 인터페이스에 대한 엑셀은 앞으로 가야 한다.
하지만 자식 클래스에서 의도와 다르게 뒤로 가게 구현하면 이를 어기게 되어 예측하지 못한 버그가 발생할 수 있다.


ISP : Interface Segregation Principle (인터페이스 분리 원칙 )
특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
이를 풀어서 얘기하면 기능 수행을 위한 스펙을 가진 인터페이스는 해당 기능만 수행하기 위해 존재해야 한다.
구현에 불필요한 스펙이 있거나 역할이 나눠져 있지 않다면 강한 강결합을 가진다.

자동차는 운전과 정비, 폐차라는 기능의 집합체이다.  만약 자동차에 대한 구현을 운전, 정비, 폐차라는 각 인터페이스로 분리하여 구현한다면
하나의 인터페이스(스펙, 기능)에 대한 변경이 필요하다면 해당 인터페이스(또는 인터페이스를 구현한 클래스)만 수정하면 된다.
예로 자동차를 사용하는 클라이언트 입장에서는 정비 인터페이스가 변해도 운전 클라이언트에는 영향을 미치지 않는다.


DIP : Dependency Inversion Principle(의존관계 역전 원칙)
추상에 대해 의존해야지, 구체에 의존하면 안 된다. 구체 클래스 대신 인터페이스라는 추상화에 의존해야 한다는 것이다.
이는 스프링 프레임워크가
이는 DI와 OCP와도 밀접한 관계를 가진다. 의존성 주입이 구체 클래스에 대해 의존하면 구현체를 유연하게 변경하기 어렵다.
구현체에 의존하면 변경, 확장 등이 일어날 때, 기존 코드의 변경이 발생한다..
